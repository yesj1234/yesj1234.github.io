<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" href="../favicon.png" />
		<link rel="stylesheet" href="/styles/app.css" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		
		<link href="../_app/immutable/assets/0.BwancY7n.css" rel="stylesheet">
		<link href="../_app/immutable/assets/3.noKbvbNA.css" rel="stylesheet">
		<link href="../_app/immutable/assets/ArticleMeta.VMQ7KKaF.css" rel="stylesheet">
		<link rel="modulepreload" href="../_app/immutable/entry/start.totQVT8G.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/entry.BjXhztgk.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/scheduler.BR55WShb.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/index.CXVSoEhx.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/control.CYgJF_JY.js">
		<link rel="modulepreload" href="../_app/immutable/entry/app.ab6CEODS.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/preload-helper.D6kgxu3v.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/index.DZHVcTXD.js">
		<link rel="modulepreload" href="../_app/immutable/nodes/0.BeLlwaxg.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/each.D6YF6ztN.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/header.vhBZ3ANe.js">
		<link rel="modulepreload" href="../_app/immutable/nodes/3.u1DtSKSV.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/index.CzR0xuCU.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/PageHead.DxCapelc.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/ArticleMeta.B7E3AiTX.js"><title>Flutter App Architecture(1) - MVVM | yesj1234.github.io</title><!-- HEAD_svelte-1jfag13_START --><meta property="og:site_name" content="yesj1234.github.io"><meta property="og:title" content="Flutter App Architecture(1) - MVVM"><meta property="og:description" content="MVVM(Model View ViewModel)아키텍처에 대해 알아봅니다."><!-- HEAD_svelte-1jfag13_END -->
	</head>
	<body data-sveltekit-preload-data="hover">
		<div style="display: contents">  <div class="sidebar-and-main svelte-d6nbxv"><div class="sidebar2 svelte-d6nbxv"><div class="container svelte-76a3v9"><div class="sidebar svelte-76a3v9"><div class="menu svelte-76a3v9"><button type="button" class="menu-item svelte-76a3v9" data-svelte-h="svelte-4rz7h9"><i class="fa-regular fa-copy"></i></button> <div class="menu-item svelte-76a3v9" data-svelte-h="svelte-608ww5"><i class="fa-solid fa-magnifying-glass"></i></div> <button class="menu-item svelte-76a3v9" data-svelte-h="svelte-1fo943y"><a href="/"><i class="fa-solid fa-house"></i></a></button></div></div> <div class="sidebar-folders svelte-76a3v9 closed" style="width: 0px; transition: width 0.3s ease;"><button class="root-folder svelte-76a3v9"><div class="root-folder-title svelte-76a3v9"><span class="arrow-icon svelte-76a3v9" data-svelte-h="svelte-w8ixat"><i class="fa-solid fa-chevron-right"></i></span> <span class="root-folder svelte-76a3v9" data-svelte-h="svelte-1ag9bxk">YESJ1234.GITHUB.IO</span></div></button> </div> </div></div> <div class="main svelte-d6nbxv"><div class="header-container svelte-d6nbxv"><div><div class="container svelte-18ebzw"></div> </div></div> <div class="container svelte-rlxdxu"><div class="metadata svelte-rlxdxu"> <h2 class="heading svelte-1ujuesn large" id="flutter-app-architecture--mvvm"><a href="#flutter-app-architecture--mvvm">Flutter App Architecture(1) - MVVM</a></h2> <p class="svelte-1uy9i9h"><div class="tags svelte-1uy9i9h"><span data-svelte-h="svelte-190wkx9">Tags:</span> <div class="tag-items-container svelte-1uy9i9h"><span class="tag svelte-1uy9i9h">Flutter</span></div></div></p> <div class="metadata svelte-1uy9i9h"><span class="date svelte-1uy9i9h">2024. 11. 23. (Sat)</span> </div></div> <div class="component svelte-rlxdxu"><nav class="toc" data-svelte-h="svelte-ywqxgp"><ol class="toc-level toc-level-1"><li class="toc-item toc-item-h1"><a class="toc-link toc-link-h1" href="#separation-of-concerns">Separation of concerns</a></li><li class="toc-item toc-item-h1"><a class="toc-link toc-link-h1" href="#layered-architectures-in-flutter-app">Layered Architectures in Flutter App</a><ol class="toc-level toc-level-2"><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#mvvm-architecture">MVVM Architecture</a><ol class="toc-level toc-level-3"><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#ui-layer">UI Layer</a><ol class="toc-level toc-level-4"><li class="toc-item toc-item-h4"><a class="toc-link toc-link-h4" href="#view">View</a></li><li class="toc-item toc-item-h4"><a class="toc-link toc-link-h4" href="#viewmodel">ViewModel</a></li></ol></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#datamodel-layer">Data(Model) Layer</a><ol class="toc-level toc-level-4"><li class="toc-item toc-item-h4"><a class="toc-link toc-link-h4" href="#repository">Repository</a></li><li class="toc-item toc-item-h4"><a class="toc-link toc-link-h4" href="#service">Service</a></li></ol></li></ol></li></ol></li><li class="toc-item toc-item-h1"><a class="toc-link toc-link-h1" href="#best-practices">Best practices</a><ol class="toc-level toc-level-2"><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#separation-of-concerns-1">Separation of concerns</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#handling-data">Handling data</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#app-structure">App structure</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#testing">Testing</a></li></ol></li><li class="toc-item toc-item-h1"><a class="toc-link toc-link-h1" href="#sources">Sources</a></li></ol></nav> <p data-svelte-h="svelte-1eusmwg">Architecture란 용어는 문맥에 따라 다양한 의미를 지니는 단어이기 때문에 한 문장으로 정의하기 애매한 단어입니다.<br>
앱을 개발하는 관점에서 Architecture는 유지 보수성, 확장성을 고려하여 앱을 어떻게 구조화/체계화/설계 할지에 대한 방법이라고 생각 할 수 있습니다.
이러한 아키텍처를 고민하고 앱을 개발하면 여러가지 이점을 얻을 수 있습니다.</p> <p data-svelte-h="svelte-zk26ri">좋은 아키텍처는…</p> <ul data-svelte-h="svelte-1di92tr"><li><strong>유지 보수성(Maintainability)</strong> : 앱의 새로운 기능을 추가하거나 업데이트 혹은 수정에 유연하게 대응할 수 있습니다.</li> <li><strong>확장성(Scalability)</strong> : 많은 개발자들이 동시에 개발에 참여할 수 있습니다.</li> <li><strong>쉬운 테스트 코드 작성(Testability)</strong> : 간단한 class와 잘 정의된 인터페이스는 좋은 테스트를 할 수 있게 도와줍니다.</li> <li><strong>새로운 개발자의 낮은 학습 곡선(Lower cognitive load)</strong> : 높은 가독성을 확보 할 수 있고, 앱의 아키텍처를 아는 개발자들은 많은 노력 없이도 프로젝트 개발에 참여할 수 있습니다.</li> <li><strong>더 나은 유저 경험(Better user experience)</strong> : 새로운 기능 개발이 빨라지고 버그가 줄어듭니다.</li></ul> <p data-svelte-h="svelte-1bmggdm">아키텍처를 선정할 때 가장 중요하게 고려할 것은 <strong>관심사의 분리</strong>(Separation of concerns)입니다.</p> <h1 id="separation-of-concerns" data-svelte-h="svelte-1yohh3a">Separation of concerns</h1> <p data-svelte-h="svelte-tpbvui"><strong>관심사의 분리</strong>(<a href="https://en.wikipedia.org/wiki/Separation_of_concerns" rel="nofollow">Separation of concerns</a>)는 프로그램을 여러 개의 구별되는 영역으로 분리하는 디자인 원칙입니다.</p> <p data-svelte-h="svelte-180yg1a"><strong>관심사</strong>(Concern)란 프로그램에 영향을 주는 정보의 집합체입니다.</p> <p data-svelte-h="svelte-1nx708n">이러한 관심사의 분리는 각 영역이 담당하는 관심사를 다른 영역으로부터 숨기고(Encapsulating) 잘 정의된 인터페이스를 통해 다른 영역과 소통함으로써 이루어집니다.</p> <p data-svelte-h="svelte-1gztqdn">웹이나 앱에서 많이 사용하는 레이어드(Layered) 아키텍처는 이러한 관심사의 분리 디자인 원칙의 구현입니다.
레이어드(Layered), 즉 층이 나눠져 있다는 것은 각 레이어가 인접한 레이어와만 소통할 수 있다는 의미가 담겨져 있습니다.</p> <p data-svelte-h="svelte-15uolt0">이번 글에선 이런 레이어드 아키텍처 중 <strong>MVVM</strong> 아키텍처에 대해서 알아보도록 하겠습니다.</p> <h1 id="layered-architectures-in-flutter-app" data-svelte-h="svelte-1aomaom">Layered Architectures in Flutter App</h1> <p data-svelte-h="svelte-9y79nu">이 글은 <a href="https://docs.flutter.dev/app-architecture" rel="nofollow">플러터팀이 작성한 App architecture</a> 을 읽고 정리한 내용입니다. 참고 부탁드립니다.</p> <p data-svelte-h="svelte-ppep6n"><strong>용어 정의하기</strong></p> <p data-svelte-h="svelte-fh5nyu">레이어드 아키텍처는 관심사 분리 원칙의 구현이라는 것을 알았습니다.</p> <p data-svelte-h="svelte-1lhfegz">하지만 앱의 영역을 어떻게 분리할 지에 대한 부분은 각 아키텍처에 과제로 남아 있습니다.</p> <p data-svelte-h="svelte-175zdjl">그러다 보니 각 아키텍처 마다 각 영역이 담당하는 관심사가 조금씩 달라 지고 자연스럽게 용어의 의미도 다르게 사용되곤 합니다.</p> <p data-svelte-h="svelte-e4af9b">따라서 아키텍처를 선택할 때는 아키텍처에서 사용 되는 용어를 정확히 숙지할 필요가 있습니다.</p> <p data-svelte-h="svelte-1niughr"><strong>공통되는 레이어</strong></p> <p data-svelte-h="svelte-awcsi3">각 아키텍처마다 관심사를 분리하는 기준이 달라진다고 해도 공통되는 큰 틀은 어느정도 정해져있습니다.
일반적으로 앱의 복잡도에 따라 레이어를 크게 2~3개로 나눌 수 있습니다.</p> <ul data-svelte-h="svelte-a948f4"><li><strong>UI layer</strong> : 유저에게 데이터를 어떻게 보여줄지와 유저와의 상호작용을 담당하는 레이어입니다. Presentation layer라고도 합니다.</li> <li><strong>Logic layer</strong> : 데이터에 관련된 비즈니스 로직을 담당합니다.</li> <li><strong>Data layer</strong> : 외부 데이터베이스나 플랫폼 플러그인과의 소통을 담당합니다.</li></ul> <p data-svelte-h="svelte-sef003"><strong>일관된 데이터 관리와 단방향 데이터 흐름</strong></p> <p data-svelte-h="svelte-yuny0j">앱에서 사용 되는 모든 데이터 타입은 일관된 데이터를 가져야합니다. 이는 데이터를 단 한 곳에서만 관리, 제공해야 함을 의미합니다.</p> <p data-svelte-h="svelte-odbm14">일반적으로 Data layer에 있는 Repository가 데이터를 관리, 제공합니다.</p> <p data-svelte-h="svelte-1raucqc"><img src="/unidirectional_data_flow.png" alt="Unidirectional_data_flow"></p> <p data-svelte-h="svelte-3fq6g">유저의 상호작용으로 인한 데이터의 변경도 마찬가지로 최종적인 데이터를 변경하는 곳은 Data layer이어야 합니다.<br>
유저의 상호작용으로 인한 데이터의 변경은 다음과 같은 단방향 데이터 흐름을 갖습니다.</p> <ol data-svelte-h="svelte-139rto8"><li><strong>[UI Layer]</strong> : 클릭과 같은 유저 상호작용이 일어나면 그 클릭에 걸려있는 콜백이 실행됩니다. 해당 콜백은 Logic layer가 인터페이스로 UI layer에 제공하는 메서드입니다.</li> <li><strong>[Logic Layer]</strong> : 해당 콜백은 Data layer가 Logic layer에 인터페이스로 제공하는 메서드입니다. 해당 메서드를 실행시키기 전에 필요한 비즈니스 로직이 있다면 Logic layer에서 이를 담당합니다. 최종적인 데이터의 변경은 Data layer의 메서드가 담당합니다.</li> <li><strong>[Data Layer]</strong> : Logic layer에 인터페이스로 제공한 메서드가 실행됩니다. 실행된 메서드의 리턴값을 Logic layer로 전달합니다. 이는 곧 데이터의 업데이트를 의미하기도 합니다.</li> <li><strong>[Logic Layer]</strong> : Data layer로 리턴값을 받고 State를 업데이트합니다. 업데이트 된 리턴값을 UI에 전달합니다.</li> <li><strong>[UI Layer]</strong> : Logic layer로 부터 리턴값을 받고 업데이트 된 state를 이용해 UI를 업데이트합니다.</li></ol> <p data-svelte-h="svelte-1f0jamv"><strong>Flutter에서 UI는 (불변)상태에 대한 함수다</strong></p> <p data-svelte-h="svelte-3ilkq3">Flutter는 선언적(declarative)이기 때문에 Flutter에서의 UI는 현재 상태를 반영한 결과값입니다.</p> <p data-svelte-h="svelte-1biyj6i">항상 염두에 두어야 할 점은 데이터가 UI를 결정해야 한다는 점입니다. UI관점에서 데이터는 불변 값 이어야하며
최대한 데이터와 관련된 비즈니스 로직을 포함하지 않아야 합니다.</p> <p data-svelte-h="svelte-1w92vdb">이런 특징은 앱이 종료 되었을 때 데이터의 유실을 최소화 할 수 있고 테스트에 유용하며 버그가 발생할 가능성을 낮춰줍니다.</p> <h2 id="mvvm-architecture" data-svelte-h="svelte-eb6d5d">MVVM Architecture</h2> <p data-svelte-h="svelte-gl7kbr">MVVM(Model, View, ViewModel) 아키텍처에서 사용하는 용어에 대한 정의를 먼저 하고 가도록 합시다.
MVVM아키텍처는 크게 <strong>UI layer</strong>와 <strong>Data(model) layer</strong>로 나눌 수 있습니다.</p> <p data-svelte-h="svelte-w4p7qw"><img src="/MVVM.png" alt="MVVM"></p> <ul data-svelte-h="svelte-1k109u6"><li><strong>UI Layer</strong><ul><li>View : 유저에게 데이터를 어떻게 보여줄지에 대한 화면을 정의합니다. 일반적으로는 Scaffold위젯을 갖는 하나의 페이지라고 생각할 수 있으며 ViewModel에 유저 인터랙션으로 인해 발생하는 이벤트를 전달합니다.</li> <li>ViewModel : Repository가 전달하는 데이터를 View가 UI를 그리는데 필요한 state로 가공하는 역할을 합니다. 여러 Repository로 부터 정보를 받아 합쳐서 전달하거나 적절한 type으로 변환하는 등의 로직을 수행합니다.</li></ul></li> <li><strong>Data(Model) Layer</strong><ul><li>Repository : 유일한 데이터의 원천(Single Source of Truth)역할을 합니다. Serivce로 부터 데이터를 받아오고 Domain model로 변환한 후 ViewModel로 전달합니다.</li> <li>Service : 데이터베이스, REST endpoint, local file 등의 앱 외부와 소통하는 게이트웨이입니다. Repository에 Future나 Stream과 같은 형식으로 데이터를 제공하며 데이터 로딩에 관한 역할만 수행합니다.</li></ul></li> <li><strong>Domain model</strong> : 앱에서 필요한 데이터의 모양을 결정합니다. Repository에서 원본 데이터를 Domain model로 변환하고 ViewModel에서 Domain model을 가지고 비즈니스 로직을 수행합니다.</li></ul> <hr> <h3 id="ui-layer" data-svelte-h="svelte-15kk0u9">UI Layer</h3> <p data-svelte-h="svelte-15v93c1">UI layer는 유저에게 데이터를 보여주고 버튼 클릭과 같은 유저의 행동 혹은 입력폼 제출과 같은 이벤트를 담당합니다.</p> <p data-svelte-h="svelte-1gnsodk">MVVM 아키텍처에서는 UI layer를 다시 View, ViewModel로 나눕니다.</p> <p data-svelte-h="svelte-q89ipa">View와 ViewModel은 1대1 관계를 갖습니다.</p> <h4 id="view" data-svelte-h="svelte-1mfif8y">View</h4> <p data-svelte-h="svelte-1bc8uud">유저에게 데이터를 어떻게 보여줄지 정합니다. Flutter는 앱을 Widget들의 조합으로 하나의 페이지를 구성합니다. 예를 들어 하나의 View는 Scaffold 위젯을 포함하는 페이지가 될 수 있습니다. 유저의 입력이나 클릭과 같은 상호작용으로 발생하는 이벤트를 ViewModel로 전달합니다.</p> <p data-svelte-h="svelte-2f5pj0">View는 데이터와 관련된 비즈니스 로직을 포함해서는 안됩니다.
데이터와 관련된 모든 비즈니스 로직은 ViewModel에서 수행되어야 하며 결과값만을 받아 사용해야 합니다.</p> <p data-svelte-h="svelte-14d95i5">View에서 처리할 수 있는 비즈니스 로직은 다음과 같이 한정됩니다.</p> <ul data-svelte-h="svelte-91zhor"><li>화면에 표시할 위젯을 정할 간단한 분기처리 로직(if statement와 같은)</li> <li>애니메이션에 필요한 로직</li> <li>서로 다른 디바이스를 위한 반응형 로직</li> <li>페이지 라우팅 로직</li></ul> <h4 id="viewmodel" data-svelte-h="svelte-k2mdda">ViewModel</h4> <p data-svelte-h="svelte-1q5kq01">View가 필요로 하는 데이터를 제공하는 역할을 합니다.
Repository로부터 받은 app data들을 1대1로 대응하는 View가 필요로 하는 데이터 형태로 가공하여 전달합니다.</p> <p data-svelte-h="svelte-zzqkii">ViewModel의 주된 관심사는 다음과 같습니다.</p> <ul data-svelte-h="svelte-lwep7f"><li>Repository로 부터 데이터를 전달받아 1대1로 대응되는 View에 필요한 데이터 형태로 가공하기. 예를 들어, 여러 repository로 부터 데이터를 받아 하나로 묶거나, 받은 데이터를 특정 조건에 맞게 필터링하는 로직을 수행합니다.</li> <li>View가 화면을 그리는데 필요한 상태(State)를 관리합니다. 예를 들어, 화면에 특정 위젯을 보여줄지에 대한 boolean flag, 캐러셀의 어느 부분을 표시할 지에 대한 상태값 등이 이에 포함됩니다.</li> <li>View의 이벤트 핸들러가 사용할 콜백(command)을 제공해야합니다. Dart에서는 이 command를 ViewModel 클래스의 멤버로 정의하여 사용하며 메서드로 View에 제공됩니다.</li></ul> <hr> <h3 id="datamodel-layer" data-svelte-h="svelte-ww5d12">Data(Model) Layer</h3> <p data-svelte-h="svelte-blvicc">MVVM 아키텍처는 Data(Model) layer를 Repository , Service 로 나눕니다.</p> <h4 id="repository" data-svelte-h="svelte-rjlvm2">Repository</h4> <p data-svelte-h="svelte-126p2pa">Repository는 유일한 데이터의 원천(Single Source of Truth)역할을 합니다.
Serivce로 부터 데이터를 받아오고 Domain model로 변환한 후 ViewModel로 전달합니다.</p> <p data-svelte-h="svelte-ynejht">Repository는 Service에 다음과 같은 관련된 비즈니스 로직을 수행합니다.</p> <ul data-svelte-h="svelte-c231og"><li><strong>캐싱</strong></li> <li><strong>에러 핸들링</strong></li> <li><strong>재요청</strong></li> <li><strong>새로고침</strong></li> <li>데이터를 주기적으로 확인하기위한 <strong>Polling</strong></li></ul> <p data-svelte-h="svelte-6pwgaf">Repository는 ViewModel에 데이터를 전달할 때 DomainModel에 정의된 형태로 가공하여 데이터를 전달하여야 합니다.</p> <p data-svelte-h="svelte-1ssi0de">소셜 미디어 앱을 예로 들어보면 유저 프로필 데이터를 관리하기 위한 UserProfileRepository가 있을 수 있습니다.</p> <p data-svelte-h="svelte-1wav8we">유저의 로그인 상태에 따라 UserProfileRepository는 <code>Stream&lt;UserProfile?&gt;</code>을 제공할 것이고 이때 UserProfile이 Domain model이며 ViewModel에서 사용되는 데이터의 형태입니다.</p> <p data-svelte-h="svelte-1s2o27k">이런 <strong>Domain model과 Repository가 1대1로</strong> 대응되어 관리되어야 합니다.</p> <p data-svelte-h="svelte-18pq45f"><strong>Repository와 ViewModel은 다대다</strong> 관계를 갖습니다.
하나의 ViewModel은 여러 Repository로 부터 데이터를 받아와 사용할 수 있고 마찬가지로 하나의 Repository는 여러 ViewModel로 부터 호출될 수 있습니다.</p> <p data-svelte-h="svelte-pnd3u4">Repository끼리는 서로 영향을 주어선 안됩니다. 만약 서로 다른 Repository로 부터 데이터를 받아와 비즈니스 로직을 수행해야 한다면 이 과정은 반드시 ViewModel 혹은 Domain layer에서 수행되어야 합니다.</p> <h4 id="service" data-svelte-h="svelte-uzfxtk">Service</h4> <p data-svelte-h="svelte-vowklj">Services는 데이터베이스, REST endpoint, local file 등의 앱 외부와 소통하는 게이트웨이 역할입니다.</p> <p data-svelte-h="svelte-igy28h">Repository에 Future나 Stream과 같은 형식으로 데이터를 제공하며 데이터 로딩에 관한 역할만 수행하며 상태에 관한 정보를 가져서는 안됩니다.</p> <p data-svelte-h="svelte-1lhs5g6"><strong>Service와 외부 Data source는 1대1</strong> 관계를 갖습니다.</p> <p data-svelte-h="svelte-qhd11g">외부 Data source는 다음과 같은것들을 의미합니다.</p> <ul data-svelte-h="svelte-7oxca4"><li><strong>iOS나 Android API와 같은 플랫폼</strong></li> <li><strong>REST endpoints</strong></li> <li><strong>로컬 파일</strong></li></ul> <p data-svelte-h="svelte-1qeerrz"><strong>Service 와 Repository는 다대다 관계</strong>를 갖습니다. 하나의 Service는 여러 Repository에서 사용될 수 있으며 하나의 Repository는 여러 Service로 부터 데이터를 받아와 사용할 수 있습니다.</p> <hr> <h1 id="best-practices" data-svelte-h="svelte-1x1lml5">Best practices</h1> <h2 id="separation-of-concerns-1" data-svelte-h="svelte-381k9a">Separation of concerns</h2> <p data-svelte-h="svelte-171gdjw"><strong>Strongly recommended</strong></p> <ol data-svelte-h="svelte-asd56e"><li>UI Layer &amp; Data Layer의 명확한 분리</li> <li>Data Layer에서 Repository pattern 사용</li> <li>UI Layer에서 View 와 ViewModel 사용</li> <li>widget 안에 비즈니스 로직 포함시키지 않기</li></ol> <p data-svelte-h="svelte-1muxh7d"><strong>Conditional</strong></p> <ol data-svelte-h="svelte-1c2hxdn"><li>widget에 업데이트가 필요할 경우엔 ChangeNotifier 혹은 Listenable 사용</li> <li>Domain Layer 사용</li></ol> <h2 id="handling-data" data-svelte-h="svelte-1bu6ot">Handling data</h2> <p data-svelte-h="svelte-171gdjw"><strong>Strongly recommended</strong></p> <ol data-svelte-h="svelte-yo2zs2"><li>단방향 데이터 흐름을 통해 데이터 관리</li> <li>data model은 불변 타입으로 사용</li></ol> <p data-svelte-h="svelte-1kxmhh6"><strong>Recommended</strong></p> <ol data-svelte-h="svelte-14jhq3q"><li>Command pattern을 사용해 유저와의 상호작용으로 발생하는 이벤트 관리</li> <li>freezed 같은 코드 제너레이터를 사용해 data model 관리</li></ol> <p data-svelte-h="svelte-1muxh7d"><strong>Conditional</strong></p> <ol data-svelte-h="svelte-1hu0kin"><li>API 모델과 domain 모델 분리하여 만들기</li></ol> <h2 id="app-structure" data-svelte-h="svelte-cncpcp">App structure</h2> <p data-svelte-h="svelte-171gdjw"><strong>Strongly recommended</strong></p> <ol data-svelte-h="svelte-1uymljc"><li>의존성 주입 패턴 사용</li> <li>Abstract repository 사용</li></ol> <p data-svelte-h="svelte-1kxmhh6"><strong>Recommended</strong></p> <ol data-svelte-h="svelte-1lmb718"><li>go_router를 사용</li> <li>파일, 디렉토리, 클래스 이름 지을 때 표준화된 규칙 사용하기</li></ol> <h2 id="testing" data-svelte-h="svelte-1eblalq">Testing</h2> <p data-svelte-h="svelte-171gdjw"><strong>Strongly recommended</strong></p> <ol data-svelte-h="svelte-l57inl"><li>Test architectural components separately and together</li> <li>Make fakes for testing (and write code that takes advantages of fakes.)</li></ol> <h1 id="sources" data-svelte-h="svelte-22jvrw">Sources</h1> <ul data-svelte-h="svelte-1pokob4"><li><a href="https://docs.flutter.dev/app-architecture" rel="nofollow">https://docs.flutter.dev/app-architecture</a></li></ul></div> </div></div> </div> 
			
			<script>
				{
					__sveltekit_14qnypk = {
						base: new URL("..", location).pathname.slice(0, -1)
					};

					const element = document.currentScript.parentElement;

					const data = [{"type":"data","data":{publishedPosts:[{slug:"push_notifications",title:"How to send push notification",author:"jack",date:"2025. 05. 16",published:true,description:"Flutter 앱에서 사용자에게 알림을 보내는 방법에 대해 알아봅니다.",tags:["Firebase"]},{slug:"dart_async",title:"Dart asynchronous programming",author:"jack",description:"Dart에서 비동기를 구현하는 방식에 대해 알아보고 예시를 통해 학습 해봅니다.",published:true,date:"2025. 03. 27.",tags:["Dart"]},{slug:"understanding_hero_animation",title:"Understanding Flutter Hero animations process",description:"Flutter Hero animation에 대해 알아봅니다.",author:"jack",published:true,date:"2025. 02. 22.",tags:["Flutter"]},{slug:"dart_docs",title:"Effective Dart",description:"How to document my code.",author:"jack",published:true,date:"2025. 02. 17.",tags:["Dart"]},{slug:"union_types",title:"Union types in dart",description:"Union type에 대해 알아봅시다.",author:"jack",published:true,date:"2024. 12. 26.",tags:["Dart"]},{slug:"flutter_app_architecture2",title:"Flutter App Architecture(2) - Riverpod Architecture",author:"jack",description:"Riverpod 아키텍처에 대해 알아봅니다.",published:true,date:"2024. 12. 10.",tags:["Flutter"]},{slug:"flutter_app_architecture",title:"Flutter App Architecture(1) - MVVM",author:"jack",description:"MVVM(Model View ViewModel)아키텍처에 대해 알아봅니다.",published:true,date:"2024. 11. 23.",tags:["Flutter"]},{slug:"riverpod",title:"Flutter Package - Riverpod, State management tool",description:"Learn the core concept of provider and basic features of Riverpod.",author:"jack",published:true,date:"2024. 11. 08.",tags:["Flutter"]},{slug:"responsive_layout",title:"Responsive layout in Flutter(1)",description:"How to build responsive layout in flutter application. Learn about SafeArea, MediaQuery, LayoutBuilder and some best practices.",author:"jack",date:"2024. 10. 30.",published:true,tags:["Flutter"]},{slug:"flutter_ui_challenge3",title:"Flutter UI Challenge(3)",description:"Learn some advanced usage of StatefulWidget, Widget builder, AnimatedWidget, and Transform.",author:"jack",date:"2024. 10. 16.",published:true,tags:["Flutter"]},{slug:"flutter_ui_challenge2",title:"Flutter UI Challenge(2)",description:"Learn how to use StatefulWidgets and animate the changes of Widget. Widgets related to animations are Animation, AnimationController, Tween, AnimatedWidget and etc..",author:"jack",date:"2024. 10. 07.",published:true,tags:["Flutter"]},{slug:"flutter_ui_challenge",title:"Flutter UI Challenge(1)",description:"Learn the basic layouts with Flutter challenges posted by Andrea. Some basic layout of flutter includes Row, Column, Stack, Expanded, Padding, etc...",author:"jack",date:"2024. 10. 05.",published:true,tags:["Flutter"]},{slug:"flutter_boilerplate_code2",title:"new Flutter project의 main.dart 코드 파헤쳐보기(2)",description:"IDE를 이용해 만든 flutter project의 초기 main.dart 코드들을 보면서 StatelessWidget, StatefulWidget, key에 대해 알아봅니다.",author:"jack",date:"2024.09. 29.",published:true,tags:["Flutter"]},{slug:"flutter_boilerplate_code1",title:"new Flutter project의 main.dart 코드 파헤쳐보기(1)",description:"IDE를 이용해 만든 flutter project의 초기 main.dart 코드들을 보면서 StatelessWidget, StatefulWidget, key에 대해 알아봅니다.",author:"jack",date:"2024.09. 27.",published:true,tags:["Flutter"]},{slug:"branches",title:"Branches in Dart",author:"jack",description:"Dart에서 Branch(분기)로 코드의 흐름을 제어하는 방법에 대해 알아봅니다.",published:true,date:"2024. 09. 24.",tags:["Dart"]},{slug:"records",title:"Record type in Dart",description:"Record type에 대해 알아봅니다.",author:"jack",date:"2024.09. 23.",published:true,tags:["Dart"]},{slug:"terminologies2",title:"헷갈리는 용어들 정리(2) - parameter & argument",description:"Dart의 Function에 대해 알아보며 parameter 와 argument 의 정확한 의미에 대해 알아봅니다.",author:"jack",published:true,date:"2024. 09. 21.",tags:["Dart"]},{slug:"terminologies1",title:"헷갈리는 용어들 정리(1) - statement & expression",description:"Dart의 switch 공식문서를 살펴보며 statement와 expression의 정의와 차이점에 대해 알아봅니다.",author:"jack",published:true,date:"2024. 09. 12.",tags:["Dart"]},{slug:"exercise2",title:"Practice Dart - exercises for beginners (2)",description:"Exercises to practice Dart.",author:"jack",published:true,date:"2024. 09. 09.",tags:["Dart"]},{slug:"exercise1",title:"Practice Dart - exercises for beginners (1)",description:"Exercises to practice Dart.",author:"jack",published:true,date:"2024. 09. 04.",tags:["Dart"]},{slug:"deploy-steps",title:"Deploy SvelteKit + MDsveX with github pages step by step.",description:"Step by step guide on how to setup SvelteKit + MDsveX and deploy it with github pages. Optional settings such as useful remark plugins, project structure setup etc. are also introduced.",author:"jack",published:true,date:"2024. 04. 22.",tags:["SvelteKit","Mdsvex","Github"]}],tags:new Set(["Firebase","Dart","Flutter","SvelteKit","Mdsvex","Github"])},"uses":{}},null];

					Promise.all([
						import("../_app/immutable/entry/start.totQVT8G.js"),
						import("../_app/immutable/entry/app.ab6CEODS.js")
					]).then(([kit, app]) => {
						kit.start(app, element, {
							node_ids: [0, 3],
							data,
							form: null,
							error: null
						});
					});
				}
			</script>
		</div>
	</body>
	<script src="https://kit.fontawesome.com/56837ace2e.js" crossorigin="anonymous"></script>
</html>
