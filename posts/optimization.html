<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" href="../favicon.png" />
		<link rel="stylesheet" href="/styles/app.css" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		
		<link href="../_app/immutable/assets/0.B8-60epR.css" rel="stylesheet">
		<link href="../_app/immutable/assets/3.CzLBGkYF.css" rel="stylesheet">
		<link href="../_app/immutable/assets/ArticleMeta.B80NBchf.css" rel="stylesheet">
		<link rel="modulepreload" href="../_app/immutable/entry/start.Dn57zYBA.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/entry.Dmx4lYQ2.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/scheduler.K4N95sjU.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/index.FT5ea4XJ.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/control.CYgJF_JY.js">
		<link rel="modulepreload" href="../_app/immutable/entry/app.CVijAazQ.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/preload-helper.D6kgxu3v.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/index.of2qq71z.js">
		<link rel="modulepreload" href="../_app/immutable/nodes/0.C2Cc29Ll.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/each.D6YF6ztN.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/header.d7U9tjLS.js">
		<link rel="modulepreload" href="../_app/immutable/nodes/3.wj1HvM9o.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/index.CzR0xuCU.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/PageHead.hPBH__w_.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/ArticleMeta.CYLej8Wy.js"><title>Optimization techniques - Image compression | yesj1234.github.io</title><!-- HEAD_svelte-1jfag13_START --><meta property="og:site_name" content="yesj1234.github.io"><meta property="og:title" content="Optimization techniques - Image compression"><meta property="og:description" content="앱을 최적화 하는 여러 가지 방법 중 이미지 압축을 통한 최적화에 대해 알아봅시다."><!-- HEAD_svelte-1jfag13_END -->
	</head>
	<body data-sveltekit-preload-data="hover">
		<div style="display: contents">  <div class="sidebar-and-main svelte-jegalg"><div class="sidebar2 svelte-jegalg"><div class="container svelte-1ugp46p"><div class="sidebar svelte-1ugp46p"><div class="menu svelte-1ugp46p"><button type="button" class="menu-item svelte-1ugp46p" data-svelte-h="svelte-s0pks6"><i class="fa-regular fa-copy"></i></button> <button class="menu-item svelte-1ugp46p" data-svelte-h="svelte-e07ql0"><i class="fa-solid fa-magnifying-glass"></i></button> <button class="menu-item svelte-1ugp46p" data-svelte-h="svelte-1fo943y"><a href="/"><i class="fa-solid fa-house"></i></a></button></div></div> <div class="sidebar-selected svelte-1ugp46p closed" style="width: 0px; transition: width 0.3s ease;"></div> </div></div> <div class="main svelte-jegalg"><div class="header-container svelte-jegalg"><div><div class="container svelte-18ebzw"></div> </div></div> <div class="container svelte-kpry1d"><div class="metadata svelte-kpry1d"> <h2 class="heading svelte-t2q6vt large" id="optimization-techniques--image-compression"><a href="#optimization-techniques--image-compression">Optimization techniques - Image compression</a></h2> <p class="svelte-1uy9i9h"><div class="tags svelte-1uy9i9h"><span data-svelte-h="svelte-190wkx9">Tags:</span> <div class="tag-items-container svelte-1uy9i9h"><span class="tag svelte-1uy9i9h">Flutter</span></div></div></p> <div class="metadata svelte-1uy9i9h"><span class="date svelte-1uy9i9h">2025. 05. 22. (Thu)</span> </div></div> <div class="component svelte-kpry1d"><nav class="toc" data-svelte-h="svelte-fl7lb6"><ol class="toc-level toc-level-1"><li class="toc-item toc-item-h1"><a class="toc-link toc-link-h1" href="#flutter-앱-최적화와-이미지-처리-기법">Flutter 앱 최적화와 이미지 처리 기법</a><ol class="toc-level toc-level-2"><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#flutter-앱의-일반적인-최적화-방안">Flutter 앱의 일반적인 최적화 방안</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#이미지-최적화-방안">이미지 최적화 방안</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#주요-이미지-포맷">주요 이미지 포맷</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#jpeg-이미지-압축의-원리">JPEG 이미지 압축의 원리</a><ol class="toc-level toc-level-3"><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#이미지-표현-영역">이미지 표현 영역</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#공간-주파수spatial-frequency">공간 주파수(Spatial Frequency)</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#dctdiscrete-cosine-transform와-jpeg-압축">DCT(Discrete Cosine Transform)와 JPEG 압축</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#기저basis의-개념">기저(Basis)의 개념</a></li></ol></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#jpeg-압축-과정">JPEG 압축 과정</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#허프만-압축huffman-coding">허프만 압축(Huffman Coding)</a><ol class="toc-level toc-level-3"><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#허프만-압축의-기본-원리">허프만 압축의 기본 원리</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#jpeg에서의-허프만-압축">JPEG에서의 허프만 압축</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#jpeg-압축의-핵심-통찰">JPEG 압축의 핵심 통찰</a></li></ol></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#android에서의-jpeg-압축">Android에서의 JPEG 압축</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#ios에서의-jpeg-압축">iOS에서의 JPEG 압축</a></li></ol></li><li class="toc-item toc-item-h1"><a class="toc-link toc-link-h1" href="#sources">Sources</a></li></ol></nav> <h1 id="flutter-앱-최적화와-이미지-처리-기법" data-svelte-h="svelte-3k7wsr">Flutter 앱 최적화와 이미지 처리 기법</h1> <p data-svelte-h="svelte-1kcdtb0">Flutter 앱을 개발할 때 최적화는 성능과 사용자 경험에 중요한 영향을 미칩니다.</p> <p data-svelte-h="svelte-8b2497">효율적인 앱 구현을 위한 다양한 최적화 방안이 있지만, 이미지 최적화에 초점을 맞춰 살펴보겠습니다.</p> <h2 id="flutter-앱의-일반적인-최적화-방안" data-svelte-h="svelte-sdqrwc">Flutter 앱의 일반적인 최적화 방안</h2> <p data-svelte-h="svelte-1f9h9z1">Flutter 앱을 최적화하는 방법은 다양하지만, 제가 자주 고려하는 네 가지 방법은 다음과 같습니다:</p> <ol data-svelte-h="svelte-19a5ye6"><li><strong>build call 횟수, 범위 최소화</strong>: 불필요한 위젯 트리 재구성을 방지하고 상태 변경의 영향 범위를 최소화</li> <li><strong>const 생성자 사용</strong>: 빌드 타임에 위젯을 생성하여 런타임 성능 향상</li> <li><strong>lazy loading</strong>: 필요한 시점에 리소스를 로드하여 초기 로딩 시간 감소</li> <li><strong>이미지 최적화</strong>: 효율적인 이미지 사용으로 앱 크기와 메모리 사용량 최소화</li></ol> <h2 id="이미지-최적화-방안" data-svelte-h="svelte-18c1yuq">이미지 최적화 방안</h2> <p data-svelte-h="svelte-1lpb5f8">이미지는 앱 크기와 성능에 큰 영향을 미치는 요소입니다. 이미지를 최적화하는 주요 기법은 다음과 같습니다:</p> <ol data-svelte-h="svelte-whwd98"><li><strong>적절한 해상도 사용 및 이미지 압축</strong>: 필요 이상의 고해상도 이미지를 사용하지 않고, 이미지 품질과 파일 크기의 균형 유지</li> <li><strong>이미지 캐싱</strong>: 한 번 로드한 이미지를 메모리나 디스크에 저장하여 재사용</li> <li><strong>lazy loading</strong>: 화면에 표시될 때만 이미지를 로드하여 초기 로딩 시간과 메모리 사용량 절감</li> <li><strong>SVG 및 벡터 이미지 사용</strong>: 다양한 화면 크기에 대응하고 파일 크기를 줄이는 벡터 그래픽 활용</li> <li><strong>이미지 포맷 선택</strong>: 상황에 맞는 최적의 이미지 포맷 선택(JPEG, PNG, WebP 등)</li> <li><strong>이미지 프리로딩</strong>: 사용자가 곧 접할 가능성이 높은 이미지를 미리 로드</li> <li><strong>에러 대응 처리</strong>: 이미지 로딩 실패 시 적절한 대응 처리</li></ol> <p data-svelte-h="svelte-jwpk7m">이 중에서도 가장 효과적인 최적화 방안인 이미지 압축에 대해 자세히 알아보겠습니다.</p> <h2 id="주요-이미지-포맷" data-svelte-h="svelte-1gaup6w">주요 이미지 포맷</h2> <p data-svelte-h="svelte-1c799sc">앱이나 웹에서 가장 보편적으로 사용되는 이미지 포맷은 다음과 같습니다:</p> <ol data-svelte-h="svelte-c6vg3q"><li><p><strong>JPEG(Joint Photographical Experts Group)</strong>: 사진과 같은 복잡한 이미지에 적합하며 손실 압축 방식을 사용하여 파일 크기를 줄이는 포맷. 투명도를 지원하지 않지만 자연스러운 이미지에서 좋은 압축률을 제공합니다.</p></li> <li><p><strong>PNG(Portable Network Graphics)</strong>: 무손실 압축 방식을 사용하며 투명도를 지원하는 포맷. 단순한 그래픽이나 투명도가 필요한 이미지에 적합합니다. 파일 크기는 JPEG보다 크지만 품질 손실이 없습니다.</p></li> <li><p><strong>WebP(Google)</strong>: Google이 개발한 현대적인 이미지 포맷으로, 손실/무손실 압축을 모두 지원하며 투명도도 지원합니다. JPEG보다 나은 압축률과 PNG보다 작은 파일 크기를 제공하여 웹과 앱에서 점점 더 많이 사용되고 있습니다.</p></li></ol> <h2 id="jpeg-이미지-압축의-원리" data-svelte-h="svelte-1cswhbv">JPEG 이미지 압축의 원리</h2> <p data-svelte-h="svelte-15vt6n9">JPEG 압축은 인간의 시각 특성을 고려한 효율적인 이미지 압축 기술입니다.</p> <p data-svelte-h="svelte-12l19k3">그 원리를 이해하기 위해서는 이미지 표현 방식에 대한 이해가 필요합니다.</p> <h3 id="이미지-표현-영역" data-svelte-h="svelte-1ubwmqi">이미지 표현 영역</h3> <p data-svelte-h="svelte-d1bv5">이미지는 크게 두 가지 영역으로 표현할 수 있습니다:</p> <ol data-svelte-h="svelte-19lrokd"><li><strong>공간 영역(Spatial Domain)</strong>: 우리가 일반적으로 보는 픽셀 기반 이미지 표현</li> <li><strong>변환 영역(Transform Domain)</strong>: 주파수 기반으로 이미지를 표현하는 방식</li></ol> <h3 id="공간-주파수spatial-frequency" data-svelte-h="svelte-1uo6353">공간 주파수(Spatial Frequency)</h3> <p data-svelte-h="svelte-c9j9h1">주파수 영역에서는 <strong>공간 주파수</strong>라는 개념을 사용합니다. 이는 화소 밝기의 변화율을 나타내는 것으로, 공간 영역에서 픽셀 값이 얼마나 빨리 변하는지를 의미합니다.</p> <ul data-svelte-h="svelte-1nqsy97"><li><strong>고주파</strong>: 밝기가 빨리 변하는 부분으로, 주로 경계나 객체의 모서리 같은 세부 디테일 영역</li> <li><strong>저주파</strong>: 밝기가 거의 변하지 않는 부분으로, 주로 배경이나 객체의 내부 영역</li></ul> <p data-svelte-h="svelte-1dvamsy">주파수 처리를 통해 이미지를 저주파와 고주파로 구분하면 다양한 응용이 가능합니다:</p> <ul data-svelte-h="svelte-zfjlz5"><li>고주파 영역을 제거하면 경계가 흐려진 부드러운 이미지를 얻을 수 있습니다.</li> <li>저주파 영역을 제거하면 경계나 모서리만 포함하는 에지 이미지를 만들 수 있습니다.</li></ul> <h3 id="dctdiscrete-cosine-transform와-jpeg-압축" data-svelte-h="svelte-1myq6id">DCT(Discrete Cosine Transform)와 JPEG 압축</h3> <p data-svelte-h="svelte-18fp4ae">JPEG 압축에서는 DCT를 사용하여 이미지를 공간 영역에서 주파수 영역으로 변환합니다. DCT를 사용하는 주된 목적은 저주파와 고주파를 분리하여 인간의 시각 특성에 맞게 압축하기 위함입니다.</p> <p data-svelte-h="svelte-1evbyk2">JPEG 압축의 목적은 인간이 인지하는 이미지 품질(인지 화질)이 크게 떨어지지 않으면서 파일 크기를 줄이는 것입니다. 이를 위해 다음과 같은 특성을 활용합니다:</p> <ol data-svelte-h="svelte-kp3hdo"><li><p>인간의 눈은 큰 변화에 민감하게 반응합니다.</p> <ul><li>저주파 영역(변화가 적은 지점)에서의 변화는 쉽게 인지됩니다.</li> <li>고주파 영역(변화가 많은 지점)에서의 변화는 상대적으로 덜 인지됩니다.</li></ul></li> <li><p>따라서 JPEG 압축은:</p> <ul><li>저주파 성분은 보존하고</li> <li>고주파 성분은 정밀도를 낮추거나 제거합니다.</li></ul></li></ol> <h3 id="기저basis의-개념" data-svelte-h="svelte-1vw065i">기저(Basis)의 개념</h3> <p data-svelte-h="svelte-ave28c">DCT에서 중요한 개념인 기저(Basis)에 대해 알아보겠습니다:</p> <p data-svelte-h="svelte-1ixtvb5">선형대수학에서 기저는 다음 두 가지 조건을 만족하는 벡터들의 집합입니다:</p> <ol data-svelte-h="svelte-ua8ztd"><li>선형 독립(각 벡터가 서로 중복되지 않음)</li> <li>공간을 생성(span): 모든 벡터는 이 기저 벡터들의 선형 결합으로 표현 가능</li></ol> <p data-svelte-h="svelte-8qny6d">예를 들어, 2차원 공간의 표준 기저는 (1,0), (0,1)입니다. 이 두 벡터로 모든 2D 벡터를 표현할 수 있습니다.</p> <p data-svelte-h="svelte-evwj1z">DCT에서는 벡터 대신 함수를 다루기 때문에, 함수 공간에서의 기저 개념을 사용합니다:</p> <ul data-svelte-h="svelte-caxhdc"><li>DCT의 기저 함수는 코사인 함수들로, 직교성(서로 내적하면 0)과 기저성(임의의 신호를 이 함수들의 선형 결합으로 표현 가능)을 가집니다.</li></ul> <h2 id="jpeg-압축-과정" data-svelte-h="svelte-1jnmii8">JPEG 압축 과정</h2> <p data-svelte-h="svelte-1erjzce">JPEG 압축은 다음과 같은 단계로 이루어집니다:</p> <ol data-svelte-h="svelte-jdiju6"><li><p><strong>색상 공간 변환</strong>: RGB 이미지를 YCbCr 색상 공간으로 변환하여 밝기(Y)와 색상(Cb, Cr) 정보를 분리합니다.</p></li> <li><p><strong>8x8 블록 분할</strong>: 이미지를 8x8 픽셀 블록으로 나누어 각 블록을 독립적으로 인코딩합니다. 각 블록은 64개의 코사인 기저 함수를 사용하여 표현됩니다.</p></li> <li><p><strong>DCT 변환</strong>: 각 8x8 블록을 주파수 영역으로 변환합니다. 이를 통해 다양한 주파수의 코사인 파형의 합으로 이미지 블록을 표현합니다.</p></li> <li><p><strong>양자화(Quantization)</strong>: 고주파 DCT 계수의 정밀도를 줄입니다. 이 과정에서 작은 값들은 0으로 바뀌어 압축 효율이 크게 향상됩니다.</p></li> <li><p><strong>지그재그 순서화</strong>: DCT 계수를 저주파에서 고주파 순으로 지그재그 패턴으로 나열하여 연속적인 0의 수를 최대화합니다.</p></li> <li><p><strong>허프만 압축</strong>: 지그재그 순서화된 계수를 효율적으로 인코딩하여 최종 압축 파일을 생성합니다.</p></li> <li><p><strong>압축 해제</strong>: 역과정을 통해 압축된 데이터에서 원본 이미지를 근사적으로 복원합니다.</p></li></ol> <h2 id="허프만-압축huffman-coding" data-svelte-h="svelte-5n9l53">허프만 압축(Huffman Coding)</h2> <p data-svelte-h="svelte-32ofw8">JPEG 압축의 마지막 단계에서 사용되는 허프만 압축은 무손실 압축 알고리즘으로, 데이터의 출현 빈도에 따라 가변 길이 코드를 할당하는 방식입니다.</p> <h3 id="허프만-압축의-기본-원리" data-svelte-h="svelte-18pm2t">허프만 압축의 기본 원리</h3> <ol data-svelte-h="svelte-1z0mzn"><li><strong>빈도 기반 코드 할당</strong>: 자주 나타나는 값에는 짧은 코드를, 드물게 나타나는 값에는 긴 코드를 할당합니다.</li> <li><strong>접두어 코드(Prefix Code)</strong>: 어떤 코드도 다른 코드의 접두어가 될 수 없도록 하여 고유한 디코딩을 보장합니다.</li> <li><strong>이진 트리 구성</strong>: 각 데이터의 발생 빈도에 기반하여 이진 트리를 구성하고, 트리의 경로를 코드로 사용합니다.</li></ol> <h3 id="jpeg에서의-허프만-압축" data-svelte-h="svelte-1e3g2y4">JPEG에서의 허프만 압축</h3> <p data-svelte-h="svelte-8oeaa3">JPEG 압축에서 허프만 코딩은 다음과 같이 적용됩니다:</p> <ol data-svelte-h="svelte-1g7l70c"><li><p><strong>DC 계수와 AC 계수 분리</strong>: 각 8x8 블록의 첫 번째 계수(DC)와 나머지 계수(AC)를 별도로 처리합니다.</p></li> <li><p><strong>런렝스 인코딩(RLE)</strong>: 지그재그 스캔 후 발생하는 연속된 0들을 (연속 길이, 다음 비제로 값) 형태로 인코딩합니다.</p></li> <li><p><strong>허프만 테이블 사용</strong>: JPEG는 표준 허프만 테이블을 제공하거나 이미지에 최적화된 커스텀 테이블을 생성할 수 있습니다.</p></li> <li><p><strong>비트스트림 생성</strong>: 최종적으로 허프만 인코딩된 값들을 비트스트림으로 변환하여 압축 파일에 저장합니다.</p></li></ol> <h3 id="jpeg-압축의-핵심-통찰" data-svelte-h="svelte-1982d8b">JPEG 압축의 핵심 통찰</h3> <ol data-svelte-h="svelte-1g31b1l"><li><p><strong>YCbCr 색상 공간의 이점</strong>:</p> <ul><li>밝기와 색상 정보를 분리하여 인간의 시각적 민감도를 활용</li> <li>색상 정보(크로미넌스)를 과감하게 다운샘플링해도 인지되는 품질 손실은 최소화</li> <li>특히 사진과 같은 이미지에서 데이터를 크게 줄이면서 시각적 완전성 유지</li></ul></li> <li><p><strong>코사인 파형을 통한 주파수 표현</strong>:</p> <ul><li>DCT는 공간적 이미지 정보를 코사인 함수의 합으로 표현</li> <li>저주파는 넓은 밝기 변화를, 고주파는 세부 디테일(에지, 텍스처)을 인코딩</li> <li>이미지 전체에 균일한 손실 없이 목표된 데이터 감소 가능</li></ul></li> <li><p><strong>8x8 블록 크기의 중요성</strong>:</p> <ul><li>관리 가능한 8x8 블록으로 나누는 것은 계산 가능성과 압축 효율성에 중요</li> <li>각 블록을 독립적으로 인코딩하여 압축 아티팩트를 작은 영역에 국한</li> <li>병렬 처리 가능</li></ul></li> <li><p><strong>양자화를 통한 제어된 데이터 손실</strong>:</p> <ul><li>높은 주파수 성분은 일반적으로 작은 계수를 가지며 인지적으로 덜 기여</li> <li>이러한 계수의 정밀도를 과감하게 줄이면(0으로) 시각적 영향 최소화하며 데이터 크게 압축</li></ul></li> <li><p><strong>지그재그 정렬과 허프만 압축의 시너지</strong>:</p> <ul><li>저주파에서 고주파 순으로 DCT 계수를 지그재그 패턴으로 정렬하면 연속된 0이 많아짐</li> <li>허프만 압축은 이러한 패턴에서 높은 효율을 보이며, 최종 파일 크기를 크게 줄임</li> <li>통계적으로 최적의 코드 길이를 할당하여 데이터 크기를 최소화</li></ul></li></ol> <h2 id="android에서의-jpeg-압축" data-svelte-h="svelte-a7ppx4">Android에서의 JPEG 압축</h2> <p data-svelte-h="svelte-1byqpwy">Android에서는 Skia 엔진을 사용하여 이미지 처리를 수행합니다. JPEG 압축은 libjpeg-turbo 라이브러리를 통해 구현되며, DCT 관리자(<code>jcdctmgr.c</code>)가 변환을 담당하고, 허프만 인코딩은 별도의 모듈에서 처리됩니다.</p> <p data-svelte-h="svelte-1dwfs9o">결론적으로, JPEG 압축은 인간의 시각적 특성을 활용하여 고주파 성분을 과감하게 줄이고 저주파 성분은 보존하는 DCT 변환과, 데이터의 통계적 특성을 이용한 허프만 코딩을 결합하여 시각적 품질을 유지하면서도 파일 크기를 크게 줄일 수 있는 효율적인 압축 기술입니다. Flutter 앱 개발에서 이러한 원리를 이해하고 적절히 활용한다면, 앱의 성능과 사용자 경험을 크게 향상시킬 수 있을 것입니다.</p> <h2 id="ios에서의-jpeg-압축" data-svelte-h="svelte-13r08r0">iOS에서의 JPEG 압축</h2> <p data-svelte-h="svelte-1hi5koh">iOS는 Android와 달리 Skia 엔진을 사용하지 않습니다. 대신 다음과 같은 프레임워크들을 사용합니다:</p> <ol data-svelte-h="svelte-uszxwe"><li><p><strong>Core Graphics</strong>: Apple의 2D 그래픽 렌더링 엔진으로, Quartz 2D라고도 불립니다. iOS와 macOS에서 기본적인 그래픽 처리를 담당합니다.</p></li> <li><p><strong>Image I/O 프레임워크</strong>: JPEG을 포함한 다양한 이미지 포맷의 읽기/쓰기를 담당하며, Apple이 최적화한 JPEG 코덱을 사용합니다.</p></li> <li><p><strong>Metal Performance Shaders</strong>: GPU 가속 이미지 처리를 위한 Apple의 고성능 컴퓨팅 프레임워크로, 이미지 압축과 디코딩에서 하드웨어 가속을 제공합니다.</p></li> <li><p><strong>UIKit/SwiftUI</strong>: 상위 레벨에서 이미지 표시와 기본적인 처리를 담당합니다.</p></li></ol> <p data-svelte-h="svelte-171kmf7">iOS는 Apple Silicon(A시리즈 프로세서)에 내장된 전용 이미지 처리 유닛과 Neural Engine을 활용하여 JPEG 압축과 해제를 더욱 효율적으로 수행할 수 있습니다.</p> <h1 id="sources" data-svelte-h="svelte-22jvrw">Sources</h1> <ul data-svelte-h="svelte-12dy0d4"><li><p><a href="https://android.googlesource.com/platform/frameworks/base/+/master/libs/hwui/hwui/Bitmap.h" rel="nofollow">https://android.googlesource.com/platform/frameworks/base/+/master/libs/hwui/hwui/Bitmap.h</a></p></li> <li><p><a href="https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/graphics/java/android/graphics/Bitmap.java" rel="nofollow">https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/graphics/java/android/graphics/Bitmap.java</a></p></li> <li><p><a href="https://github.com/libjpeg-turbo/libjpeg-turbo/blob/main/src/jcdctmgr.c" rel="nofollow">https://github.com/libjpeg-turbo/libjpeg-turbo/blob/main/src/jcdctmgr.c</a></p></li> <li><p><a href="https://www.thewebmaster.com/jpeg-definitive-guide/" rel="nofollow">https://www.thewebmaster.com/jpeg-definitive-guide/</a></p></li> <li><p><a href="https://vir-us.tistory.com/entry/2%EC%B0%A8%EC%9B%90-DCTDiscrete-cosine-transform-%EC%9D%B4%EC%82%B0-%EC%BD%94%EC%82%AC%EC%9D%B8-%EB%B3%80%ED%99%98" rel="nofollow">https://vir-us.tistory.com/entry/2%EC%B0%A8%EC%9B%90-DCTDiscrete-cosine-transform-%EC%9D%B4%EC%82%B0-%EC%BD%94%EC%82%AC%EC%9D%B8-%EB%B3%80%ED%99%98</a></p></li> <li><p><a href="https://www.youtube.com/watch?v=Q2aEzeMDHMA" rel="nofollow">https://www.youtube.com/watch?v=Q2aEzeMDHMA</a></p></li></ul></div> </div></div> </div> 
			
			<script>
				{
					__sveltekit_1ycs704 = {
						base: new URL("..", location).pathname.slice(0, -1)
					};

					const element = document.currentScript.parentElement;

					const data = [{"type":"data","data":{publishedPosts:[{slug:"optimization",title:"Optimization techniques - Image compression",description:"앱을 최적화 하는 여러 가지 방법 중 이미지 압축을 통한 최적화에 대해 알아봅시다.",author:"jack",date:"2025. 05. 22.",published:true,tags:["Flutter"]},{slug:"push_notifications",title:"How to send push notification",author:"jack",date:"2025. 05. 16",published:true,description:"Flutter 앱에서 사용자에게 알림을 보내는 방법에 대해 알아봅니다.",tags:["Firebase"]},{slug:"dart_async",title:"Dart asynchronous programming",author:"jack",description:"Dart에서 비동기를 구현하는 방식에 대해 알아보고 예시를 통해 학습 해봅니다.",published:true,date:"2025. 03. 27.",tags:["Dart"]},{slug:"understanding_hero_animation",title:"Understanding Flutter Hero animations process",description:"Flutter Hero animation에 대해 알아봅니다.",author:"jack",published:true,date:"2025. 02. 22.",tags:["Flutter"]},{slug:"dart_docs",title:"Effective Dart",description:"How to document my code.",author:"jack",published:true,date:"2025. 02. 17.",tags:["Dart"]},{slug:"union_types",title:"Union types in dart",description:"Union type에 대해 알아봅시다.",author:"jack",published:true,date:"2024. 12. 26.",tags:["Dart"]},{slug:"flutter_app_architecture2",title:"Flutter App Architecture(2) - Riverpod Architecture",author:"jack",description:"Riverpod 아키텍처에 대해 알아봅니다.",published:true,date:"2024. 12. 10.",tags:["Flutter"]},{slug:"flutter_app_architecture",title:"Flutter App Architecture(1) - MVVM",author:"jack",description:"MVVM(Model View ViewModel)아키텍처에 대해 알아봅니다.",published:true,date:"2024. 11. 23.",tags:["Flutter"]},{slug:"riverpod",title:"Flutter Package - Riverpod, State management tool",description:"Learn the core concept of provider and basic features of Riverpod.",author:"jack",published:true,date:"2024. 11. 08.",tags:["Flutter"]},{slug:"responsive_layout",title:"Responsive layout in Flutter(1)",description:"How to build responsive layout in flutter application. Learn about SafeArea, MediaQuery, LayoutBuilder and some best practices.",author:"jack",date:"2024. 10. 30.",published:true,tags:["Flutter"]},{slug:"flutter_ui_challenge3",title:"Flutter UI Challenge(3)",description:"Learn some advanced usage of StatefulWidget, Widget builder, AnimatedWidget, and Transform.",author:"jack",date:"2024. 10. 16.",published:true,tags:["Flutter"]},{slug:"flutter_ui_challenge2",title:"Flutter UI Challenge(2)",description:"Learn how to use StatefulWidgets and animate the changes of Widget. Widgets related to animations are Animation, AnimationController, Tween, AnimatedWidget and etc..",author:"jack",date:"2024. 10. 07.",published:true,tags:["Flutter"]},{slug:"flutter_ui_challenge",title:"Flutter UI Challenge(1)",description:"Learn the basic layouts with Flutter challenges posted by Andrea. Some basic layout of flutter includes Row, Column, Stack, Expanded, Padding, etc...",author:"jack",date:"2024. 10. 05.",published:true,tags:["Flutter"]},{slug:"flutter_boilerplate_code2",title:"new Flutter project의 main.dart 코드 파헤쳐보기(2)",description:"IDE를 이용해 만든 flutter project의 초기 main.dart 코드들을 보면서 StatelessWidget, StatefulWidget, key에 대해 알아봅니다.",author:"jack",date:"2024.09. 29.",published:true,tags:["Flutter"]},{slug:"flutter_boilerplate_code1",title:"new Flutter project의 main.dart 코드 파헤쳐보기(1)",description:"IDE를 이용해 만든 flutter project의 초기 main.dart 코드들을 보면서 StatelessWidget, StatefulWidget, key에 대해 알아봅니다.",author:"jack",date:"2024.09. 27.",published:true,tags:["Flutter"]},{slug:"branches",title:"Branches in Dart",author:"jack",description:"Dart에서 Branch(분기)로 코드의 흐름을 제어하는 방법에 대해 알아봅니다.",published:true,date:"2024. 09. 24.",tags:["Dart"]},{slug:"records",title:"Record type in Dart",description:"Record type에 대해 알아봅니다.",author:"jack",date:"2024.09. 23.",published:true,tags:["Dart"]},{slug:"terminologies2",title:"헷갈리는 용어들 정리(2) - parameter & argument",description:"Dart의 Function에 대해 알아보며 parameter 와 argument 의 정확한 의미에 대해 알아봅니다.",author:"jack",published:true,date:"2024. 09. 21.",tags:["Dart"]},{slug:"terminologies1",title:"헷갈리는 용어들 정리(1) - statement & expression",description:"Dart의 switch 공식문서를 살펴보며 statement와 expression의 정의와 차이점에 대해 알아봅니다.",author:"jack",published:true,date:"2024. 09. 12.",tags:["Dart"]},{slug:"exercise2",title:"Practice Dart - exercises for beginners (2)",description:"Exercises to practice Dart.",author:"jack",published:true,date:"2024. 09. 09.",tags:["Dart"]},{slug:"exercise1",title:"Practice Dart - exercises for beginners (1)",description:"Exercises to practice Dart.",author:"jack",published:true,date:"2024. 09. 04.",tags:["Dart"]},{slug:"deploy-steps",title:"Deploy SvelteKit + MDsveX with github pages step by step.",description:"Step by step guide on how to setup SvelteKit + MDsveX and deploy it with github pages. Optional settings such as useful remark plugins, project structure setup etc. are also introduced.",author:"jack",published:true,date:"2024. 04. 22.",tags:["SvelteKit","Mdsvex","Github"]}],tags:new Set(["Flutter","Firebase","Dart","SvelteKit","Mdsvex","Github"])},"uses":{}},null];

					Promise.all([
						import("../_app/immutable/entry/start.Dn57zYBA.js"),
						import("../_app/immutable/entry/app.CVijAazQ.js")
					]).then(([kit, app]) => {
						kit.start(app, element, {
							node_ids: [0, 3],
							data,
							form: null,
							error: null
						});
					});
				}
			</script>
		</div>
	</body>
	<script src="https://kit.fontawesome.com/56837ace2e.js" crossorigin="anonymous"></script>
</html>
